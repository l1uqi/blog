---
title: 前端曝光实现
top_img: false
date: 2022-11-08
categories:
  - 前端
tags:
  - 埋点
---

## 什么是曝光?

商品曝光人数：看到商品在首页、列表页、活动页面，以及在商品详情页下方的更多展现的人数。（不包括商品详情页的访客数量）
商品曝光次数：商品在店铺首页、列表页、活动页面，以及在商品详情页下方的更多展现的次数。（不包括商品详情页的浏览量）

> 通过商品曝光我们能得出商品在不同营销位的比重， 从而得出用户操作喜好

## 如何判断元素可视区域?

### Element.getBoundingClientRect()

getBoundingClientRect 方法返回一个 对象，该 DOMRect 对象提供有关元素大小及其相对于视口的位置的信息。
如果目标元素 rect 满足 top > 0  && left > 0 && bottom >= 视窗高度 && right <= 视窗宽度
便能得出元素完全在视窗内。 在长列表下 我们可以通过监听滚动条事件， 从而获取目标元素是否暴露在用户视窗内。

> 这种方法实现起来简单，兼容性相对较好，这个属性频繁计算会引发页面的重绘，当元素过多时，会造成性能问题，出现卡顿，影响使用体验。

```js
<html>

<head>
    <title>getBoundingClientRect</title>
</head>

<body>
    <style>
        body {
            margin: 0;
        }

        .rect {
            margin-top: 50px;
            width: 100%;
            height: 200px;
            background: red;
            text-align: center;
            line-height: 200px;
        }
    </style>
    <div id="contents" style="width: 100%"></div>
    <script>
        // 最大渲染条数
        const renderNumber = 100;

        let i = 0;
        // 渲染列表
        const renderList = [];

        const contents = document.getElementById("contents");

        // 已曝光
        let inVpList = [];

        const unionArray = (arr1, arr2) => {
            const newSet = new Set(arr1)
            arr2.map(item => {
                newSet.add(item)
            })
            return [...newSet].sort((a, b) => {
                return a - b;
            })
        }
        // 节流
        const throttled = (fn, delay = 500) => {
            let timer = null
            let starttime = Date.now()
            return function () {
                let curTime = Date.now() // 当前时间
                let remaining = delay - (curTime - starttime)  // 从上一次到现在，还剩下多少多余时间
                let context = this
                let args = arguments
                clearTimeout(timer)
                if (remaining <= 0) {
                    fn.apply(context, args)
                    starttime = Date.now()
                } else {
                    timer = setTimeout(fn, remaining);
                }
            }
        }

        const createElement = (number) => {
            let div = document.createElement('div');
            let textNode = document.createTextNode(number);
            div.appendChild(textNode);
            div.style.color = "white";
            div.style.fontSize = "100px";
            div.style.fontWeight = 600;
            div.className = 'rect'
            div.setAttribute("id", `div_${number}`);
            contents.appendChild(div);
            return div;
        }

        // 判断可视区域内
        const isElementInViewport = (el) => {
            let rect = el.getBoundingClientRect();
            return (
                rect.top >= 0 &&
                rect.left >= 0 &&
                rect.bottom <=
                (window.innerHeight || document.documentElement.clientHeight) &&
                rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        };

        while (i < renderNumber) {
            renderList.push(createElement(i));
            i++;
        }

        const addInVpList = (arr) => {
            return unionArray(inVpList, arr);
        }


        const handleScrollChange = (e) => {
            const list = renderList.filter(item => isElementInViewport(item)).map(item => item.textContent);
            inVpList = addInVpList(list)

            console.log(`已曝光: ${inVpList}`)
        }

        document.addEventListener('scroll', throttled(handleScrollChange))

    </script>
</body>

</html>
```

![](https://user-images.githubusercontent.com/70128222/200589085-fac93e79-b391-448b-bd81-f33cf9a352f1.gif)


### Intersection Observer API


## 实现

曝光肯定是结合埋点一起使用， 通过采集某个商品是否出现在用户的可视区域内, 进行上报。


## 参考
[IntersectionObserver API 使用教程](https://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html)